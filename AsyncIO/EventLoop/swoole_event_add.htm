<html>
<head>
<title>swoole_event_add</title>
<meta http-equiv=Content-Type content="text/html; charset=gbk">
<link rel="stylesheet" href="../../public/css/Word2Chm.css" type="text/css" />
<link rel="stylesheet" href="../../public/css/default.css" type="text/css" />
<link rel="stylesheet" href="../../public/css/noframe.css" type="text/css" />
<link rel="stylesheet" href="../../public/css/bootstrap.css" type="text/css" />
<link rel="stylesheet" href="../../public/styles/shThemeDefault.css" type="text/css"/>
<script type="text/javascript" src="../../public/scripts/shCore.js"></script>
<script type="text/javascript" src="../../public/scripts/shBrushPhp.js"></script>
<script type="text/javascript">
    SyntaxHighlighter.defaults['gutter'] = false;
    SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.all();
</script>
</head>
<body>
    <div class="wiki_content">
        <article>
            <h1>swoole_event_add</h1>
            
            <p>swoole_event_add函数用于将一个socket加入到swoole的reactor事件监听中。此函数可以用在Server或Client模式下。
                函数原型：</p>
            <pre class="brush: php;">bool swoole_event_add(int $sock, mixed $read_callback, mixed $write_callback = null, int $event_flag = null);
</pre>
            <p>参数1可以为以下三种类型：</p>
            <ul>
                <li>int，就是文件描述符,包括swoole_client的socket,以及第三方扩展的socket（比如mysql）</li>
                <li>stream资源，就是stream_socket_client/fsockopen 创建的资源</li>
                <li>sockets资源，就是sockets扩展中 socket_create创建的资源
                    需要在编译时加入 ./configure --enable-sockets</li>
            </ul>
            <p>参数2为可读回调函数，参数3为可写事件回调，可以是字符串函数名、对象+方法、类静态方法或匿名函数，当此socket可读时回调指定的函数。</p>
            <blockquote>
                <p>
                    swoole_event_add在swoole1.6.2+之后可用<br />
                    第3，4个参数在1.7.1版本后可用，用于监听可写事件回调，以及设置读写事件的监听
                </p>
            </blockquote>
            <p>
            	参数4为事件类型的掩码，可选择关闭/开启可读可写事件，如<code>SWOOLE_EVENT_READ</code>，<code>SWOOLE_EVENT_WRITE</code>，
            	或者<code>SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE</code>
        	</p>
            <p>
                在Server程序中使用，可以理解为在worker/taskworker进程中将此socket注册到epoll事件中。<br />
                在Client程序中使用，可以理解为在客户端进程中将此socket注册到epoll事件中。
            </p>
            <pre class="brush: php;">&lt;?php
$db = new mysqli;
$db->connect('127.0.0.1', 'root', 'root', 'test');
$db->query("show tables", MYSQLI_ASYNC);
swoole_event_add(swoole_get_mysqli_sock($db), function($db_sock) {
    global $db;
    $res = $db->reap_async_query();
    var_dump($res->fetch_all(MYSQLI_ASSOC));
    swoole_event_del(swoole_get_mysqli_sock($db)); // socket处理完成后，从epoll事件中移除socket 
});
$db2 = new mysqli;
$db2->connect('127.0.0.1', 'root', 'root', 'test');
$db2->query("show tables", MYSQLI_ASYNC);
swoole_event_add(swoole_get_mysqli_sock($db2), function($db_sock) {
    global $db2;
    $res = $db2->reap_async_query();
    var_dump($res->fetch_all(MYSQLI_ASSOC));
    swoole_event_del(swoole_get_mysqli_sock($db2)); // socket处理完成后，从epoll事件中移除socket 
});
echo "Finish\n";  //swoole_event_add不会阻塞进程，这行代码会顺序执行
</pre>

<h2>回调函数</h2>

<ul>
<li>在可读事件回调函数中必须使用<code>fread</code>、<code>recv</code>等函数读取Socket缓存区中的数据，否则事件会持续触发，如果不希望继续读取必须使用<code>Swoole\Event::del</code>移除事件监听</li>
<li>在可写事件回调函数中，写入socket之后必须调用<code>Swoole\Event::del</code>移除事件监听，否则可写事件会持续触发</li>
<li>执行<code>fread</code>、<code>socekt_recv</code>、<code>socket_read</code>、<code>Swoole\Client::recv</code>返回false，并且错误码为<code>EAGAIN</code>时表示当前Socket接收缓存区内没有任何数据，这时需要加入可读监听等待EventLoop通知</li>
<li>执行<code>fwrite</code>、<code>socket_write</code>、<code>socket_send</code>、<code>Swoole\Client::send</code>操作返回false，并且错误码为<code>EAGAIN</code>时表示当前Socket发送缓存区已满，暂时不能发送数据。需要监听可写事件等待EventLoop通知</li>
</ul>
        </article>
        
    </div>
</body>
</html>
